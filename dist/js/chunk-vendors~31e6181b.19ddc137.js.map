{"version":3,"sources":["webpack:///./node_modules/vue-meta/lib/vue-meta.js"],"names":["global","factory","module","exports","this","getOwnPropertySymbols","Object","hasOwnProperty","prototype","propIsEnumerable","propertyIsEnumerable","toObject","val","undefined","TypeError","shouldUseNative","assign","test1","String","getOwnPropertyNames","test2","i","fromCharCode","order2","map","n","join","test3","split","forEach","letter","keys","err","objectAssign","target","source","from","symbols","arguments$1","arguments","to","s","length","key","call","commonjsGlobal","window","self","createCommonjsModule","fn","umd","isMergeableObject","value","isNonNullObject","isSpecial","stringValue","toString","isReactElement","canUseSymbol","Symbol","for","REACT_ELEMENT_TYPE","$$typeof","emptyTarget","Array","isArray","cloneUnlessOtherwiseSpecified","options","clone","deepmerge","defaultArrayMerge","concat","element","getMergeFunction","customMerge","mergeObject","destination","arrayMerge","sourceIsArray","targetIsArray","sourceAndTargetTypesMatch","all","array","Error","reduce","prev","next","deepmerge_1","objectTag","isHostObject","result","e","overArg","func","transform","arg","funcProto","Function","objectProto","funcToString","hasOwnProperty$1","objectCtorString","objectToString","getPrototype","getPrototypeOf","isObjectLike","isPlainObject","proto","Ctor","constructor","lodash_isplainobject","arr","uniqBy","inputArray","predicate","filter","x","INFINITY","symbolTag","freeGlobal","freeSelf","root","objectProto$1","idCounter","objectToString$1","Symbol$1","symbolProto","symbolToString","baseToString","isSymbol","isObjectLike$1","uniqueId","prefix","id","lodash_uniqueid","getComponentOption","opts","component","option","deep","metaTemplateKeyName","tagIDKeyName","contentKeyName","$options","_inactive","data","$children","childComponent","meta","metaKey","metaObject","template","content","replace","escapeHTML","str","_getMetaInfo","keyName","defaultInfo","title","titleChunk","titleTemplate","htmlAttrs","bodyAttrs","headAttrs","base","link","style","script","noscript","__dangerouslyDisableSanitizers","__dangerouslyDisableSanitizersByTagID","info","targetIndex","targetItem","shared","sourceIndex","sourceItem","targetTemplate","sourceTemplate","applyTemplate","push","ref","refByTagID","escape","escaped","isDisabled","indexOf","tagID","chunk","_titleGenerator","attribute","type","text","trim","_attrsGenerator","attributeStr","watchedAttrs","attr","_tagGenerator","tags","body","tagsStr","tag","attrs","attrsStr","innerHTML","cssText","observeTag","once","hasEndTag","hasContent","_generateServerInjector","_inject","$root","_updateTitle","document","_updateTagAttributes","vueMetaAttrString","getAttribute","vueMetaAttrs","toRemove","setAttribute","saveIndex","splice","removeAttribute","toArray","bind","slice","_updateTags","headTag","bodyTag","indexToDelete","oldHeadTags","querySelectorAll","oldBodyTags","newTags","found","k","JSON","stringify","newElement","createElement","oldTags","styleSheet","appendChild","createTextNode","_attr","value$1","some","existingTag","index","isEqualNode","parentNode","removeChild","_updateClientMetaInfo","ssrAttribute","newInfo","htmlTag","getElementsByTagName","addedTags","removedTags","changed","_refresh","_$meta","inject","refresh","stopUpdate","cancelAnimationFrame","clearTimeout","startUpdate","requestAnimationFrame","cb","setTimeout","batchUpdate","callback","VUE_META_KEY_NAME","VUE_META_ATTRIBUTE","VUE_META_SERVER_RENDERED_ATTRIBUTE","VUE_META_TAG_LIST_ID_KEY_NAME","VUE_META_TEMPLATE_KEY_NAME","VUE_META_CONTENT_KEY","VueMeta","Vue","defaultOptions","$meta","batchID","mixin","beforeCreate","_hasMetaInfo","computed","$metaInfo","created","this$1","$isServer","$watch","activated","deactivated","beforeMount","destroyed","interval","setInterval","$el","offsetParent","clearInterval","$parent","use","version"],"mappings":"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","file":"js/chunk-vendors~31e6181b.19ddc137.js","sourcesContent":["/**\n * vue-meta v1.6.0\n * (c) 2019 Declan de Wet & Sébastien Chopin (@Atinux)\n * @license MIT\n */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global = global || self, global.VueMeta = factory());\n}(this, function () { 'use strict';\n\n\t/*\n\tobject-assign\n\t(c) Sindre Sorhus\n\t@license MIT\n\t*/\n\t/* eslint-disable no-unused-vars */\n\tvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\tvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\n\tfunction toObject(val) {\n\t\tif (val === null || val === undefined) {\n\t\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t\t}\n\n\t\treturn Object(val);\n\t}\n\n\tfunction shouldUseNative() {\n\t\ttry {\n\t\t\tif (!Object.assign) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\t\ttest1[5] = 'de';\n\t\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\t\tvar test2 = {};\n\t\t\tfor (var i = 0; i < 10; i++) {\n\t\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t\t}\n\t\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\t\treturn test2[n];\n\t\t\t});\n\t\t\tif (order2.join('') !== '0123456789') {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\t\tvar test3 = {};\n\t\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\t\ttest3[letter] = letter;\n\t\t\t});\n\t\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} catch (err) {\n\t\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tvar objectAssign = shouldUseNative() ? Object.assign : function (target, source) {\n\t\tvar arguments$1 = arguments;\n\n\t\tvar from;\n\t\tvar to = toObject(target);\n\t\tvar symbols;\n\n\t\tfor (var s = 1; s < arguments.length; s++) {\n\t\t\tfrom = Object(arguments$1[s]);\n\n\t\t\tfor (var key in from) {\n\t\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\t\tto[key] = from[key];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (getOwnPropertySymbols) {\n\t\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn to;\n\t};\n\n\tvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n\tfunction createCommonjsModule(fn, module) {\n\t\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n\t}\n\n\tvar umd = createCommonjsModule(function (module, exports) {\n\t(function (global, factory) {\n\t\tmodule.exports = factory();\n\t}(commonjsGlobal, (function () {\n\tvar isMergeableObject = function isMergeableObject(value) {\n\t\treturn isNonNullObject(value)\n\t\t\t&& !isSpecial(value)\n\t};\n\n\tfunction isNonNullObject(value) {\n\t\treturn !!value && typeof value === 'object'\n\t}\n\n\tfunction isSpecial(value) {\n\t\tvar stringValue = Object.prototype.toString.call(value);\n\n\t\treturn stringValue === '[object RegExp]'\n\t\t\t|| stringValue === '[object Date]'\n\t\t\t|| isReactElement(value)\n\t}\n\n\t// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\n\tvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\n\tvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\n\tfunction isReactElement(value) {\n\t\treturn value.$$typeof === REACT_ELEMENT_TYPE\n\t}\n\n\tfunction emptyTarget(val) {\n\t\treturn Array.isArray(val) ? [] : {}\n\t}\n\n\tfunction cloneUnlessOtherwiseSpecified(value, options) {\n\t\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t\t: value\n\t}\n\n\tfunction defaultArrayMerge(target, source, options) {\n\t\treturn target.concat(source).map(function(element) {\n\t\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t\t})\n\t}\n\n\tfunction getMergeFunction(key, options) {\n\t\tif (!options.customMerge) {\n\t\t\treturn deepmerge\n\t\t}\n\t\tvar customMerge = options.customMerge(key);\n\t\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n\t}\n\n\tfunction mergeObject(target, source, options) {\n\t\tvar destination = {};\n\t\tif (options.isMergeableObject(target)) {\n\t\t\tObject.keys(target).forEach(function(key) {\n\t\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t\t});\n\t\t}\n\t\tObject.keys(source).forEach(function(key) {\n\t\t\tif (!options.isMergeableObject(source[key]) || !target[key]) {\n\t\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t\t} else {\n\t\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t\t}\n\t\t});\n\t\treturn destination\n\t}\n\n\tfunction deepmerge(target, source, options) {\n\t\toptions = options || {};\n\t\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\t\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\n\t\tvar sourceIsArray = Array.isArray(source);\n\t\tvar targetIsArray = Array.isArray(target);\n\t\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\t\tif (!sourceAndTargetTypesMatch) {\n\t\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t\t} else if (sourceIsArray) {\n\t\t\treturn options.arrayMerge(target, source, options)\n\t\t} else {\n\t\t\treturn mergeObject(target, source, options)\n\t\t}\n\t}\n\n\tdeepmerge.all = function deepmergeAll(array, options) {\n\t\tif (!Array.isArray(array)) {\n\t\t\tthrow new Error('first argument should be an array')\n\t\t}\n\n\t\treturn array.reduce(function(prev, next) {\n\t\t\treturn deepmerge(prev, next, options)\n\t\t}, {})\n\t};\n\n\tvar deepmerge_1 = deepmerge;\n\n\treturn deepmerge_1;\n\n\t})));\n\t});\n\n\t/**\n\t * lodash (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modularize exports=\"npm\" -o ./`\n\t * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n\t * Released under MIT license <https://lodash.com/license>\n\t * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n\t * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t */\n\n\t/** `Object#toString` result references. */\n\tvar objectTag = '[object Object]';\n\n\t/**\n\t * Checks if `value` is a host object in IE < 9.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n\t */\n\tfunction isHostObject(value) {\n\t  // Many host objects are `Object` objects that can coerce to strings\n\t  // despite having improperly defined `toString` methods.\n\t  var result = false;\n\t  if (value != null && typeof value.toString != 'function') {\n\t    try {\n\t      result = !!(value + '');\n\t    } catch (e) {}\n\t  }\n\t  return result;\n\t}\n\n\t/**\n\t * Creates a unary function that invokes `func` with its argument transformed.\n\t *\n\t * @private\n\t * @param {Function} func The function to wrap.\n\t * @param {Function} transform The argument transform.\n\t * @returns {Function} Returns the new function.\n\t */\n\tfunction overArg(func, transform) {\n\t  return function(arg) {\n\t    return func(transform(arg));\n\t  };\n\t}\n\n\t/** Used for built-in method references. */\n\tvar funcProto = Function.prototype,\n\t    objectProto = Object.prototype;\n\n\t/** Used to resolve the decompiled source of functions. */\n\tvar funcToString = funcProto.toString;\n\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty$1 = objectProto.hasOwnProperty;\n\n\t/** Used to infer the `Object` constructor. */\n\tvar objectCtorString = funcToString.call(Object);\n\n\t/**\n\t * Used to resolve the\n\t * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n\t * of values.\n\t */\n\tvar objectToString = objectProto.toString;\n\n\t/** Built-in value references. */\n\tvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\n\t/**\n\t * Checks if `value` is object-like. A value is object-like if it's not `null`\n\t * and has a `typeof` result of \"object\".\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n\t * @example\n\t *\n\t * _.isObjectLike({});\n\t * // => true\n\t *\n\t * _.isObjectLike([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObjectLike(_.noop);\n\t * // => false\n\t *\n\t * _.isObjectLike(null);\n\t * // => false\n\t */\n\tfunction isObjectLike(value) {\n\t  return !!value && typeof value == 'object';\n\t}\n\n\t/**\n\t * Checks if `value` is a plain object, that is, an object created by the\n\t * `Object` constructor or one with a `[[Prototype]]` of `null`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.8.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n\t * @example\n\t *\n\t * function Foo() {\n\t *   this.a = 1;\n\t * }\n\t *\n\t * _.isPlainObject(new Foo);\n\t * // => false\n\t *\n\t * _.isPlainObject([1, 2, 3]);\n\t * // => false\n\t *\n\t * _.isPlainObject({ 'x': 0, 'y': 0 });\n\t * // => true\n\t *\n\t * _.isPlainObject(Object.create(null));\n\t * // => true\n\t */\n\tfunction isPlainObject(value) {\n\t  if (!isObjectLike(value) ||\n\t      objectToString.call(value) != objectTag || isHostObject(value)) {\n\t    return false;\n\t  }\n\t  var proto = getPrototype(value);\n\t  if (proto === null) {\n\t    return true;\n\t  }\n\t  var Ctor = hasOwnProperty$1.call(proto, 'constructor') && proto.constructor;\n\t  return (typeof Ctor == 'function' &&\n\t    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n\t}\n\n\tvar lodash_isplainobject = isPlainObject;\n\n\t/**\n\t * checks if passed argument is an array\n\t * @param  {any}  arr - the object to check\n\t * @return {Boolean} - true if `arr` is an array\n\t */\n\tfunction isArray (arr) {\n\t  return Array.isArray\n\t    ? Array.isArray(arr)\n\t    : Object.prototype.toString.call(arr) === '[object Array]'\n\t}\n\n\tfunction uniqBy (inputArray, predicate) {\n\t  return inputArray\n\t    .filter(function (x, i, arr) { return i === arr.length - 1\n\t      ? true\n\t      : predicate(x) !== predicate(arr[i + 1]); }\n\t    )\n\t}\n\n\t/**\n\t * lodash (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modularize exports=\"npm\" -o ./`\n\t * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n\t * Released under MIT license <https://lodash.com/license>\n\t * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n\t * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t */\n\n\t/** Used as references for various `Number` constants. */\n\tvar INFINITY = 1 / 0;\n\n\t/** `Object#toString` result references. */\n\tvar symbolTag = '[object Symbol]';\n\n\t/** Detect free variable `global` from Node.js. */\n\tvar freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n\n\t/** Detect free variable `self`. */\n\tvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n\t/** Used as a reference to the global object. */\n\tvar root = freeGlobal || freeSelf || Function('return this')();\n\n\t/** Used for built-in method references. */\n\tvar objectProto$1 = Object.prototype;\n\n\t/** Used to generate unique IDs. */\n\tvar idCounter = 0;\n\n\t/**\n\t * Used to resolve the\n\t * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n\t * of values.\n\t */\n\tvar objectToString$1 = objectProto$1.toString;\n\n\t/** Built-in value references. */\n\tvar Symbol$1 = root.Symbol;\n\n\t/** Used to convert symbols to primitives and strings. */\n\tvar symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,\n\t    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n\t/**\n\t * The base implementation of `_.toString` which doesn't convert nullish\n\t * values to empty strings.\n\t *\n\t * @private\n\t * @param {*} value The value to process.\n\t * @returns {string} Returns the string.\n\t */\n\tfunction baseToString(value) {\n\t  // Exit early for strings to avoid a performance hit in some environments.\n\t  if (typeof value == 'string') {\n\t    return value;\n\t  }\n\t  if (isSymbol(value)) {\n\t    return symbolToString ? symbolToString.call(value) : '';\n\t  }\n\t  var result = (value + '');\n\t  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n\t}\n\n\t/**\n\t * Checks if `value` is object-like. A value is object-like if it's not `null`\n\t * and has a `typeof` result of \"object\".\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n\t * @example\n\t *\n\t * _.isObjectLike({});\n\t * // => true\n\t *\n\t * _.isObjectLike([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObjectLike(_.noop);\n\t * // => false\n\t *\n\t * _.isObjectLike(null);\n\t * // => false\n\t */\n\tfunction isObjectLike$1(value) {\n\t  return !!value && typeof value == 'object';\n\t}\n\n\t/**\n\t * Checks if `value` is classified as a `Symbol` primitive or object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n\t * @example\n\t *\n\t * _.isSymbol(Symbol.iterator);\n\t * // => true\n\t *\n\t * _.isSymbol('abc');\n\t * // => false\n\t */\n\tfunction isSymbol(value) {\n\t  return typeof value == 'symbol' ||\n\t    (isObjectLike$1(value) && objectToString$1.call(value) == symbolTag);\n\t}\n\n\t/**\n\t * Converts `value` to a string. An empty string is returned for `null`\n\t * and `undefined` values. The sign of `-0` is preserved.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to process.\n\t * @returns {string} Returns the string.\n\t * @example\n\t *\n\t * _.toString(null);\n\t * // => ''\n\t *\n\t * _.toString(-0);\n\t * // => '-0'\n\t *\n\t * _.toString([1, 2, 3]);\n\t * // => '1,2,3'\n\t */\n\tfunction toString(value) {\n\t  return value == null ? '' : baseToString(value);\n\t}\n\n\t/**\n\t * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n\t *\n\t * @static\n\t * @since 0.1.0\n\t * @memberOf _\n\t * @category Util\n\t * @param {string} [prefix=''] The value to prefix the ID with.\n\t * @returns {string} Returns the unique ID.\n\t * @example\n\t *\n\t * _.uniqueId('contact_');\n\t * // => 'contact_104'\n\t *\n\t * _.uniqueId();\n\t * // => '105'\n\t */\n\tfunction uniqueId(prefix) {\n\t  var id = ++idCounter;\n\t  return toString(prefix) + id;\n\t}\n\n\tvar lodash_uniqueid = uniqueId;\n\n\t/**\n\t * Returns the `opts.option` $option value of the given `opts.component`.\n\t * If methods are encountered, they will be bound to the component context.\n\t * If `opts.deep` is true, will recursively merge all child component\n\t * `opts.option` $option values into the returned result.\n\t *\n\t * @param  {Object} opts - options\n\t * @param  {Object} opts.component - Vue component to fetch option data from\n\t * @param  {String} opts.option - what option to look for\n\t * @param  {Boolean} opts.deep - look for data in child components as well?\n\t * @param  {Function} opts.arrayMerge - how should arrays be merged?\n\t * @param  {Object} [result={}] - result so far\n\t * @return {Object} result - final aggregated result\n\t */\n\tfunction getComponentOption (opts, result) {\n\t  if ( result === void 0 ) result = {};\n\n\t  var component = opts.component;\n\t  var option = opts.option;\n\t  var deep = opts.deep;\n\t  var arrayMerge = opts.arrayMerge;\n\t  var metaTemplateKeyName = opts.metaTemplateKeyName;\n\t  var tagIDKeyName = opts.tagIDKeyName;\n\t  var contentKeyName = opts.contentKeyName;\n\t  var $options = component.$options;\n\n\t  if (component._inactive) { return result }\n\n\t  // only collect option data if it exists\n\t  if (typeof $options[option] !== 'undefined' && $options[option] !== null) {\n\t    var data = $options[option];\n\n\t    // if option is a function, replace it with it's result\n\t    if (typeof data === 'function') {\n\t      data = data.call(component);\n\t    }\n\n\t    if (typeof data === 'object') {\n\t      // merge with existing options\n\t      result = umd(result, data, { arrayMerge: arrayMerge });\n\t    } else {\n\t      result = data;\n\t    }\n\t  }\n\n\t  // collect & aggregate child options if deep = true\n\t  if (deep && component.$children.length) {\n\t    component.$children.forEach(function (childComponent) {\n\t      result = getComponentOption({\n\t        component: childComponent,\n\t        option: option,\n\t        deep: deep,\n\t        arrayMerge: arrayMerge\n\t      }, result);\n\t    });\n\t  }\n\t  if (metaTemplateKeyName && result.hasOwnProperty('meta')) {\n\t    result.meta = Object.keys(result.meta).map(function (metaKey) {\n\t      var metaObject = result.meta[metaKey];\n\t      if (!metaObject.hasOwnProperty(metaTemplateKeyName) || !metaObject.hasOwnProperty(contentKeyName) || typeof metaObject[metaTemplateKeyName] === 'undefined') {\n\t        return result.meta[metaKey]\n\t      }\n\n\t      var template = metaObject[metaTemplateKeyName];\n\t      delete metaObject[metaTemplateKeyName];\n\n\t      if (template) {\n\t        metaObject.content = typeof template === 'function' ? template(metaObject.content) : template.replace(/%s/g, metaObject.content);\n\t      }\n\n\t      return metaObject\n\t    });\n\t    result.meta = uniqBy(\n\t      result.meta,\n\t      function (metaObject) { return metaObject.hasOwnProperty(tagIDKeyName) ? metaObject[tagIDKeyName] : lodash_uniqueid(); }\n\t    );\n\t  }\n\t  return result\n\t}\n\n\tvar escapeHTML = function (str) { return typeof window === 'undefined'\n\t  // server-side escape sequence\n\t  ? String(str)\n\t    .replace(/&/g, '&amp;')\n\t    .replace(/</g, '&lt;')\n\t    .replace(/>/g, '&gt;')\n\t    .replace(/\"/g, '&quot;')\n\t    .replace(/'/g, '&#x27;')\n\t  // client-side escape sequence\n\t  : String(str)\n\t    .replace(/&/g, '\\u0026')\n\t    .replace(/</g, '\\u003c')\n\t    .replace(/>/g, '\\u003e')\n\t    .replace(/\"/g, '\\u0022')\n\t    .replace(/'/g, '\\u0027'); };\n\n\tfunction _getMetaInfo (options) {\n\t  if ( options === void 0 ) options = {};\n\n\t  var keyName = options.keyName;\n\t  var tagIDKeyName = options.tagIDKeyName;\n\t  var metaTemplateKeyName = options.metaTemplateKeyName;\n\t  var contentKeyName = options.contentKeyName;\n\t  /**\n\t   * Returns the correct meta info for the given component\n\t   * (child components will overwrite parent meta info)\n\t   *\n\t   * @param  {Object} component - the Vue instance to get meta info from\n\t   * @return {Object} - returned meta info\n\t   */\n\t  return function getMetaInfo (component) {\n\t    // set some sane defaults\n\t    var defaultInfo = {\n\t      title: '',\n\t      titleChunk: '',\n\t      titleTemplate: '%s',\n\t      htmlAttrs: {},\n\t      bodyAttrs: {},\n\t      headAttrs: {},\n\t      meta: [],\n\t      base: [],\n\t      link: [],\n\t      style: [],\n\t      script: [],\n\t      noscript: [],\n\t      __dangerouslyDisableSanitizers: [],\n\t      __dangerouslyDisableSanitizersByTagID: {}\n\t    };\n\n\t    // collect & aggregate all metaInfo $options\n\t    var info = getComponentOption({\n\t      component: component,\n\t      option: keyName,\n\t      deep: true,\n\t      metaTemplateKeyName: metaTemplateKeyName,\n\t      tagIDKeyName: tagIDKeyName,\n\t      contentKeyName: contentKeyName,\n\t      arrayMerge: function arrayMerge (target, source) {\n\t        // we concat the arrays without merging objects contained in,\n\t        // but we check for a `vmid` property on each object in the array\n\t        // using an O(1) lookup associative array exploit\n\t        // note the use of \"for in\" - we are looping through arrays here, not\n\t        // plain objects\n\t        var destination = [];\n\t        for (var targetIndex in target) {\n\t          var targetItem = target[targetIndex];\n\t          var shared = false;\n\t          for (var sourceIndex in source) {\n\t            var sourceItem = source[sourceIndex];\n\t            if (targetItem[tagIDKeyName] && targetItem[tagIDKeyName] === sourceItem[tagIDKeyName]) {\n\t              var targetTemplate = targetItem[metaTemplateKeyName];\n\t              var sourceTemplate = sourceItem[metaTemplateKeyName];\n\t              if (targetTemplate && !sourceTemplate) {\n\t                sourceItem[contentKeyName] = applyTemplate(component)(targetTemplate)(sourceItem[contentKeyName]);\n\t              }\n\t              // If template defined in child but content in parent\n\t              if (targetTemplate && sourceTemplate && !sourceItem[contentKeyName]) {\n\t                sourceItem[contentKeyName] = applyTemplate(component)(sourceTemplate)(targetItem[contentKeyName]);\n\t                delete sourceItem[metaTemplateKeyName];\n\t              }\n\t              shared = true;\n\t              break\n\t            }\n\t          }\n\n\t          if (!shared) {\n\t            destination.push(targetItem);\n\t          }\n\t        }\n\n\t        return destination.concat(source)\n\t      }\n\t    });\n\n\t    // Remove all \"template\" tags from meta\n\n\t    // backup the title chunk in case user wants access to it\n\t    if (info.title) {\n\t      info.titleChunk = info.title;\n\t    }\n\n\t    // replace title with populated template\n\t    if (info.titleTemplate) {\n\t      info.title = applyTemplate(component)(info.titleTemplate)(info.titleChunk || '');\n\t    }\n\n\t    // convert base tag to an array so it can be handled the same way\n\t    // as the other tags\n\t    if (info.base) {\n\t      info.base = Object.keys(info.base).length ? [info.base] : [];\n\t    }\n\n\t    var ref = info.__dangerouslyDisableSanitizers;\n\t    var refByTagID = info.__dangerouslyDisableSanitizersByTagID;\n\n\t    // sanitizes potentially dangerous characters\n\t    var escape = function (info) { return Object.keys(info).reduce(function (escaped, key) {\n\t      var isDisabled = ref && ref.indexOf(key) > -1;\n\t      var tagID = info[tagIDKeyName];\n\t      if (!isDisabled && tagID) {\n\t        isDisabled = refByTagID && refByTagID[tagID] && refByTagID[tagID].indexOf(key) > -1;\n\t      }\n\t      var val = info[key];\n\t      escaped[key] = val;\n\t      if (key === '__dangerouslyDisableSanitizers' || key === '__dangerouslyDisableSanitizersByTagID') {\n\t        return escaped\n\t      }\n\t      if (!isDisabled) {\n\t        if (typeof val === 'string') {\n\t          escaped[key] = escapeHTML(val);\n\t        } else if (lodash_isplainobject(val)) {\n\t          escaped[key] = escape(val);\n\t        } else if (isArray(val)) {\n\t          escaped[key] = val.map(escape);\n\t        } else {\n\t          escaped[key] = val;\n\t        }\n\t      } else {\n\t        escaped[key] = val;\n\t      }\n\n\t      return escaped\n\t    }, {}); };\n\n\t    // merge with defaults\n\t    info = umd(defaultInfo, info);\n\n\t    // begin sanitization\n\t    info = escape(info);\n\n\t    return info\n\t  }\n\t}\n\n\tvar applyTemplate = function (component) { return function (template) { return function (chunk) { return typeof template === 'function' ? template.call(component, chunk) : template.replace(/%s/g, chunk); }; }; };\n\n\tfunction _titleGenerator (options) {\n\t  if ( options === void 0 ) options = {};\n\n\t  var attribute = options.attribute;\n\n\t  /**\n\t   * Generates title output for the server\n\t   *\n\t   * @param  {'title'} type - the string \"title\"\n\t   * @param  {String} data - the title text\n\t   * @return {Object} - the title generator\n\t   */\n\t  return function titleGenerator (type, data) {\n\t    return {\n\t      text: function text () {\n\t        return String(data).trim() ? (\"<\" + type + \" \" + attribute + \"=\\\"true\\\">\" + data + \"</\" + type + \">\") : ''\n\t      }\n\t    }\n\t  }\n\t}\n\n\tfunction _attrsGenerator (options) {\n\t  if ( options === void 0 ) options = {};\n\n\t  var attribute = options.attribute;\n\n\t  /**\n\t   * Generates tag attributes for use on the server.\n\t   *\n\t   * @param  {('bodyAttrs'|'htmlAttrs'|'headAttrs')} type - the type of attributes to generate\n\t   * @param  {Object} data - the attributes to generate\n\t   * @return {Object} - the attribute generator\n\t   */\n\t  return function attrsGenerator (type, data) {\n\t    return {\n\t      text: function text () {\n\t        var attributeStr = '';\n\t        var watchedAttrs = [];\n\t        for (var attr in data) {\n\t          if (data.hasOwnProperty(attr)) {\n\t            watchedAttrs.push(attr);\n\t            attributeStr += (typeof data[attr] !== 'undefined'\n\t                ? (attr + \"=\\\"\" + (data[attr]) + \"\\\"\")\n\t                : attr) + \" \";\n\t          }\n\t        }\n\t        attributeStr += attribute + \"=\\\"\" + (watchedAttrs.join(',')) + \"\\\"\";\n\t        return attributeStr.trim()\n\t      }\n\t    }\n\t  }\n\t}\n\n\tfunction _tagGenerator (options) {\n\t  if ( options === void 0 ) options = {};\n\n\t  var attribute = options.attribute;\n\n\t  /**\n\t   * Generates meta, base, link, style, script, noscript tags for use on the server\n\t   *\n\t   * @param  {('meta'|'base'|'link'|'style'|'script'|'noscript')} the name of the tag\n\t   * @param  {(Array<Object>|Object)} tags - an array of tag objects or a single object in case of base\n\t   * @return {Object} - the tag generator\n\t   */\n\t  return function tagGenerator (type, tags) {\n\t    return {\n\t      text: function text (ref) {\n\t        if ( ref === void 0 ) ref = {};\n\t        var body = ref.body; if ( body === void 0 ) body = false;\n\n\t        // build a string containing all tags of this type\n\t        return tags.reduce(function (tagsStr, tag) {\n\t          if (Object.keys(tag).length === 0) { return tagsStr } // Bail on empty tag object\n\t          if (!!tag.body !== body) { return tagsStr }\n\t          // build a string containing all attributes of this tag\n\t          var attrs = Object.keys(tag).reduce(function (attrsStr, attr) {\n\t            switch (attr) {\n\t              // these attributes are treated as children on the tag\n\t              case 'innerHTML':\n\t              case 'cssText':\n\t              case 'once':\n\t                return attrsStr\n\t              // these form the attribute list for this tag\n\t              default:\n\t                if ([options.tagIDKeyName, 'body'].indexOf(attr) !== -1) {\n\t                  return (attrsStr + \" data-\" + attr + \"=\\\"\" + (tag[attr]) + \"\\\"\")\n\t                }\n\t                return typeof tag[attr] === 'undefined'\n\t                  ? (attrsStr + \" \" + attr)\n\t                  : (attrsStr + \" \" + attr + \"=\\\"\" + (tag[attr]) + \"\\\"\")\n\t            }\n\t          }, '').trim();\n\n\t          // grab child content from one of these attributes, if possible\n\t          var content = tag.innerHTML || tag.cssText || '';\n\n\t          // generate tag exactly without any other redundant attribute\n\t          var observeTag = tag.once\n\t            ? ''\n\t            : (attribute + \"=\\\"true\\\" \");\n\n\t          // these tags have no end tag\n\t          var hasEndTag = ['base', 'meta', 'link'].indexOf(type) === -1;\n\n\t          // these tag types will have content inserted\n\t          var hasContent = hasEndTag && ['noscript', 'script', 'style'].indexOf(type) > -1;\n\n\t          // the final string for this specific tag\n\t          return !hasContent\n\t            ? (tagsStr + \"<\" + type + \" \" + observeTag + attrs + (hasEndTag ? '/' : '') + \">\")\n\t            : (tagsStr + \"<\" + type + \" \" + observeTag + attrs + \">\" + content + \"</\" + type + \">\")\n\t        }, '')\n\t      }\n\t    }\n\t  }\n\t}\n\n\tfunction _generateServerInjector (options) {\n\t  if ( options === void 0 ) options = {};\n\n\t  /**\n\t   * Converts a meta info property to one that can be stringified on the server\n\t   *\n\t   * @param  {String} type - the type of data to convert\n\t   * @param  {(String|Object|Array<Object>)} data - the data value\n\t   * @return {Object} - the new injector\n\t   */\n\t  return function generateServerInjector (type, data) {\n\t    switch (type) {\n\t      case 'title':\n\t        return _titleGenerator(options)(type, data)\n\t      case 'htmlAttrs':\n\t      case 'bodyAttrs':\n\t      case 'headAttrs':\n\t        return _attrsGenerator(options)(type, data)\n\t      default:\n\t        return _tagGenerator(options)(type, data)\n\t    }\n\t  }\n\t}\n\n\tfunction _inject (options) {\n\t  if ( options === void 0 ) options = {};\n\n\t  /**\n\t   * Converts the state of the meta info object such that each item\n\t   * can be compiled to a tag string on the server\n\t   *\n\t   * @this {Object} - Vue instance - ideally the root component\n\t   * @return {Object} - server meta info with `toString` methods\n\t   */\n\t  return function inject () {\n\t    // get meta info with sensible defaults\n\t    var info = _getMetaInfo(options)(this.$root);\n\n\t    // generate server injectors\n\t    for (var key in info) {\n\t      if (info.hasOwnProperty(key) && key !== 'titleTemplate' && key !== 'titleChunk') {\n\t        info[key] = _generateServerInjector(options)(key, info[key]);\n\t      }\n\t    }\n\n\t    return info\n\t  }\n\t}\n\n\tfunction _updateTitle () {\n\t  /**\n\t   * Updates the document title\n\t   *\n\t   * @param  {String} title - the new title of the document\n\t   */\n\t  return function updateTitle (title) {\n\t    if ( title === void 0 ) title = document.title;\n\n\t    document.title = title;\n\t  }\n\t}\n\n\tfunction _updateTagAttributes (options) {\n\t  if ( options === void 0 ) options = {};\n\n\t  var attribute = options.attribute;\n\n\t  /**\n\t   * Updates the document's html tag attributes\n\t   *\n\t   * @param  {Object} attrs - the new document html attributes\n\t   * @param  {HTMLElement} tag - the HTMLElement tag to update with new attrs\n\t   */\n\t  return function updateTagAttributes (attrs, tag) {\n\t    var vueMetaAttrString = tag.getAttribute(attribute);\n\t    var vueMetaAttrs = vueMetaAttrString ? vueMetaAttrString.split(',') : [];\n\t    var toRemove = [].concat(vueMetaAttrs);\n\t    for (var attr in attrs) {\n\t      if (attrs.hasOwnProperty(attr)) {\n\t        var val = attrs[attr] || '';\n\t        tag.setAttribute(attr, val);\n\t        if (vueMetaAttrs.indexOf(attr) === -1) {\n\t          vueMetaAttrs.push(attr);\n\t        }\n\t        var saveIndex = toRemove.indexOf(attr);\n\t        if (saveIndex !== -1) {\n\t          toRemove.splice(saveIndex, 1);\n\t        }\n\t      }\n\t    }\n\t    var i = toRemove.length - 1;\n\t    for (; i >= 0; i--) {\n\t      tag.removeAttribute(toRemove[i]);\n\t    }\n\t    if (vueMetaAttrs.length === toRemove.length) {\n\t      tag.removeAttribute(attribute);\n\t    } else {\n\t      tag.setAttribute(attribute, vueMetaAttrs.join(','));\n\t    }\n\t  }\n\t}\n\n\t// borrow the slice method\n\tvar toArray = Function.prototype.call.bind(Array.prototype.slice);\n\n\tfunction _updateTags (options) {\n\t  if ( options === void 0 ) options = {};\n\n\t  var attribute = options.attribute;\n\n\t  /**\n\t   * Updates meta tags inside <head> and <body> on the client. Borrowed from `react-helmet`:\n\t   * https://github.com/nfl/react-helmet/blob/004d448f8de5f823d10f838b02317521180f34da/src/Helmet.js#L195-L245\n\t   *\n\t   * @param  {('meta'|'base'|'link'|'style'|'script'|'noscript')} type - the name of the tag\n\t   * @param  {(Array<Object>|Object)} tags - an array of tag objects or a single object in case of base\n\t   * @return {Object} - a representation of what tags changed\n\t   */\n\t  return function updateTags (type, tags, headTag, bodyTag) {\n\t    var oldHeadTags = toArray(headTag.querySelectorAll((type + \"[\" + attribute + \"]\")));\n\t    var oldBodyTags = toArray(bodyTag.querySelectorAll((type + \"[\" + attribute + \"][data-body=\\\"true\\\"]\")));\n\t    var newTags = [];\n\t    var indexToDelete;\n\n\t    if (tags.length > 1) {\n\t      // remove duplicates that could have been found by merging tags\n\t      // which include a mixin with metaInfo and that mixin is used\n\t      // by multiple components on the same page\n\t      var found = [];\n\t      tags = tags.map(function (x) {\n\t        var k = JSON.stringify(x);\n\t        if (found.indexOf(k) < 0) {\n\t          found.push(k);\n\t          return x\n\t        }\n\t      }).filter(function (x) { return x; });\n\t    }\n\n\t    if (tags && tags.length) {\n\t      tags.forEach(function (tag) {\n\t        var newElement = document.createElement(type);\n\t        var oldTags = tag.body !== true ? oldHeadTags : oldBodyTags;\n\n\t        for (var attr in tag) {\n\t          if (tag.hasOwnProperty(attr)) {\n\t            if (attr === 'innerHTML') {\n\t              newElement.innerHTML = tag.innerHTML;\n\t            } else if (attr === 'cssText') {\n\t              if (newElement.styleSheet) {\n\t                newElement.styleSheet.cssText = tag.cssText;\n\t              } else {\n\t                newElement.appendChild(document.createTextNode(tag.cssText));\n\t              }\n\t            } else if ([options.tagIDKeyName, 'body'].indexOf(attr) !== -1) {\n\t              var _attr = \"data-\" + attr;\n\t              var value = (typeof tag[attr] === 'undefined') ? '' : tag[attr];\n\t              newElement.setAttribute(_attr, value);\n\t            } else {\n\t              var value$1 = (typeof tag[attr] === 'undefined') ? '' : tag[attr];\n\t              newElement.setAttribute(attr, value$1);\n\t            }\n\t          }\n\t        }\n\n\t        newElement.setAttribute(attribute, 'true');\n\n\t        // Remove a duplicate tag from domTagstoRemove, so it isn't cleared.\n\t        if (oldTags.some(function (existingTag, index) {\n\t          indexToDelete = index;\n\t          return newElement.isEqualNode(existingTag)\n\t        })) {\n\t          oldTags.splice(indexToDelete, 1);\n\t        } else {\n\t          newTags.push(newElement);\n\t        }\n\t      });\n\t    }\n\t    var oldTags = oldHeadTags.concat(oldBodyTags);\n\t    oldTags.forEach(function (tag) { return tag.parentNode.removeChild(tag); });\n\t    newTags.forEach(function (tag) {\n\t      if (tag.getAttribute('data-body') === 'true') {\n\t        bodyTag.appendChild(tag);\n\t      } else {\n\t        headTag.appendChild(tag);\n\t      }\n\t    });\n\n\t    return { oldTags: oldTags, newTags: newTags }\n\t  }\n\t}\n\n\tfunction _updateClientMetaInfo (options) {\n\t  if ( options === void 0 ) options = {};\n\n\t  var ssrAttribute = options.ssrAttribute;\n\n\t  /**\n\t   * Performs client-side updates when new meta info is received\n\t   *\n\t   * @param  {Object} newInfo - the meta info to update to\n\t   */\n\t  return function updateClientMetaInfo (newInfo) {\n\t    var htmlTag = document.getElementsByTagName('html')[0];\n\t    // if this is not a server render, then update\n\t    if (htmlTag.getAttribute(ssrAttribute) === null) {\n\t      // initialize tracked changes\n\t      var addedTags = {};\n\t      var removedTags = {};\n\n\t      Object.keys(newInfo).forEach(function (key) {\n\t        switch (key) {\n\t          // update the title\n\t          case 'title':\n\t            _updateTitle(options)(newInfo.title);\n\t            break\n\t          // update attributes\n\t          case 'htmlAttrs':\n\t            _updateTagAttributes(options)(newInfo[key], htmlTag);\n\t            break\n\t          case 'bodyAttrs':\n\t            _updateTagAttributes(options)(newInfo[key], document.getElementsByTagName('body')[0]);\n\t            break\n\t          case 'headAttrs':\n\t            _updateTagAttributes(options)(newInfo[key], document.getElementsByTagName('head')[0]);\n\t            break\n\t          // ignore these\n\t          case 'titleChunk':\n\t          case 'titleTemplate':\n\t          case 'changed':\n\t          case '__dangerouslyDisableSanitizers':\n\t            break\n\t          // catch-all update tags\n\t          default:\n\t            var headTag = document.getElementsByTagName('head')[0];\n\t            var bodyTag = document.getElementsByTagName('body')[0];\n\t            var ref = _updateTags(options)(key, newInfo[key], headTag, bodyTag);\n\t        var oldTags = ref.oldTags;\n\t        var newTags = ref.newTags;\n\t            if (newTags.length) {\n\t              addedTags[key] = newTags;\n\t              removedTags[key] = oldTags;\n\t            }\n\t        }\n\t      });\n\n\t      // emit \"event\" with new info\n\t      if (typeof newInfo.changed === 'function') {\n\t        newInfo.changed.call(this, newInfo, addedTags, removedTags);\n\t      }\n\t    } else {\n\t      // remove the server render attribute so we can update on changes\n\t      htmlTag.removeAttribute(ssrAttribute);\n\t    }\n\t  }\n\t}\n\n\tfunction _refresh (options) {\n\t  if ( options === void 0 ) options = {};\n\n\t  /**\n\t   * When called, will update the current meta info with new meta info.\n\t   * Useful when updating meta info as the result of an asynchronous\n\t   * action that resolves after the initial render takes place.\n\t   *\n\t   * Credit to [Sébastien Chopin](https://github.com/Atinux) for the suggestion\n\t   * to implement this method.\n\t   *\n\t   * @return {Object} - new meta info\n\t   */\n\t  return function refresh () {\n\t    var info = _getMetaInfo(options)(this.$root);\n\t    _updateClientMetaInfo(options).call(this, info);\n\t    return info\n\t  }\n\t}\n\n\tfunction _$meta (options) {\n\t  if ( options === void 0 ) options = {};\n\n\t  /**\n\t   * Returns an injector for server-side rendering.\n\t   * @this {Object} - the Vue instance (a root component)\n\t   * @return {Object} - injector\n\t   */\n\t  return function $meta () {\n\t    return {\n\t      inject: _inject(options).bind(this),\n\t      refresh: _refresh(options).bind(this)\n\t    }\n\t  }\n\t}\n\n\t// fallback to timers if rAF not present\n\tvar stopUpdate = (typeof window !== 'undefined' ? window.cancelAnimationFrame : null) || clearTimeout;\n\tvar startUpdate = (typeof window !== 'undefined' ? window.requestAnimationFrame : null) || (function (cb) { return setTimeout(cb, 0); });\n\n\t/**\n\t * Performs a batched update. Uses requestAnimationFrame to prevent\n\t * calling a function too many times in quick succession.\n\t * You need to pass it an ID (which can initially be `null`),\n\t * but be sure to overwrite that ID with the return value of batchUpdate.\n\t *\n\t * @param  {(null|Number)} id - the ID of this update\n\t * @param  {Function} callback - the update to perform\n\t * @return {Number} id - a new ID\n\t */\n\tfunction batchUpdate (id, callback) {\n\t  stopUpdate(id);\n\t  return startUpdate(function () {\n\t    id = null;\n\t    callback();\n\t  })\n\t}\n\n\t/**\n\t * These are constant variables used throughout the application.\n\t */\n\n\t// This is the name of the component option that contains all the information that\n\t// gets converted to the various meta tags & attributes for the page.\n\tvar VUE_META_KEY_NAME = 'metaInfo';\n\n\t// This is the attribute vue-meta augments on elements to know which it should\n\t// manage and which it should ignore.\n\tvar VUE_META_ATTRIBUTE = 'data-vue-meta';\n\n\t// This is the attribute that goes on the `html` tag to inform `vue-meta`\n\t// that the server has already generated the meta tags for the initial render.\n\tvar VUE_META_SERVER_RENDERED_ATTRIBUTE = 'data-vue-meta-server-rendered';\n\n\t// This is the property that tells vue-meta to overwrite (instead of append)\n\t// an item in a tag list. For example, if you have two `meta` tag list items\n\t// that both have `vmid` of \"description\", then vue-meta will overwrite the\n\t// shallowest one with the deepest one.\n\tvar VUE_META_TAG_LIST_ID_KEY_NAME = 'vmid';\n\n\t// This is the key name for possible meta templates\n\tvar VUE_META_TEMPLATE_KEY_NAME = 'template';\n\n\t// This is the key name for the content-holding property\n\tvar VUE_META_CONTENT_KEY = 'content';\n\n\t// automatic install\n\tif (typeof window !== 'undefined' && typeof window.Vue !== 'undefined') {\n\t  Vue.use(VueMeta);\n\t}\n\n\t/**\n\t * Plugin install function.\n\t * @param {Function} Vue - the Vue constructor.\n\t */\n\tfunction VueMeta (Vue, options) {\n\t  if ( options === void 0 ) options = {};\n\n\t  // set some default options\n\t  var defaultOptions = {\n\t    keyName: VUE_META_KEY_NAME,\n\t    contentKeyName: VUE_META_CONTENT_KEY,\n\t    metaTemplateKeyName: VUE_META_TEMPLATE_KEY_NAME,\n\t    attribute: VUE_META_ATTRIBUTE,\n\t    ssrAttribute: VUE_META_SERVER_RENDERED_ATTRIBUTE,\n\t    tagIDKeyName: VUE_META_TAG_LIST_ID_KEY_NAME\n\t  };\n\t  // combine options\n\t  options = objectAssign(defaultOptions, options);\n\n\t  // bind the $meta method to this component instance\n\t  Vue.prototype.$meta = _$meta(options);\n\n\t  // store an id to keep track of DOM updates\n\t  var batchID = null;\n\n\t  // watch for client side component updates\n\t  Vue.mixin({\n\t    beforeCreate: function beforeCreate () {\n\t      // Add a marker to know if it uses metaInfo\n\t      // _vnode is used to know that it's attached to a real component\n\t      // useful if we use some mixin to add some meta tags (like nuxt-i18n)\n\t      if (typeof this.$options[options.keyName] !== 'undefined') {\n\t        this._hasMetaInfo = true;\n\t      }\n\t      // coerce function-style metaInfo to a computed prop so we can observe\n\t      // it on creation\n\t      if (typeof this.$options[options.keyName] === 'function') {\n\t        if (typeof this.$options.computed === 'undefined') {\n\t          this.$options.computed = {};\n\t        }\n\t        this.$options.computed.$metaInfo = this.$options[options.keyName];\n\t      }\n\t    },\n\t    created: function created () {\n\t      var this$1 = this;\n\n\t      // if computed $metaInfo exists, watch it for updates & trigger a refresh\n\t      // when it changes (i.e. automatically handle async actions that affect metaInfo)\n\t      // credit for this suggestion goes to [Sébastien Chopin](https://github.com/Atinux)\n\t      if (!this.$isServer && this.$metaInfo) {\n\t        this.$watch('$metaInfo', function () {\n\t          // batch potential DOM updates to prevent extraneous re-rendering\n\t          batchID = batchUpdate(batchID, function () { return this$1.$meta().refresh(); });\n\t        });\n\t      }\n\t    },\n\t    activated: function activated () {\n\t      var this$1 = this;\n\n\t      if (this._hasMetaInfo) {\n\t        // batch potential DOM updates to prevent extraneous re-rendering\n\t        batchID = batchUpdate(batchID, function () { return this$1.$meta().refresh(); });\n\t      }\n\t    },\n\t    deactivated: function deactivated () {\n\t      var this$1 = this;\n\n\t      if (this._hasMetaInfo) {\n\t        // batch potential DOM updates to prevent extraneous re-rendering\n\t        batchID = batchUpdate(batchID, function () { return this$1.$meta().refresh(); });\n\t      }\n\t    },\n\t    beforeMount: function beforeMount () {\n\t      var this$1 = this;\n\n\t      // batch potential DOM updates to prevent extraneous re-rendering\n\t      if (this._hasMetaInfo) {\n\t        batchID = batchUpdate(batchID, function () { return this$1.$meta().refresh(); });\n\t      }\n\t    },\n\t    destroyed: function destroyed () {\n\t      var this$1 = this;\n\n\t      // do not trigger refresh on the server side\n\t      if (this.$isServer) { return }\n\t      // re-render meta data when returning from a child component to parent\n\t      if (this._hasMetaInfo) {\n\t        // Wait that element is hidden before refreshing meta tags (to support animations)\n\t        var interval = setInterval(function () {\n\t          if (this$1.$el && this$1.$el.offsetParent !== null) { return }\n\t          clearInterval(interval);\n\t          if (!this$1.$parent) { return }\n\t          batchID = batchUpdate(batchID, function () { return this$1.$meta().refresh(); });\n\t        }, 50);\n\t      }\n\t    }\n\t  });\n\t}\n\n\tvar version = \"1.6.0\";\n\n\tVueMeta.version = version;\n\n\treturn VueMeta;\n\n}));\n"],"sourceRoot":""}